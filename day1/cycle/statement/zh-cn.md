{{ self.title() }}

{{ s('问题描述') }}

在 C 部落，每 5 年就会举行一次大型的祭祀活动，大祭司会在远古符阵上念动真言，召唤出 $n$ 个位置的小精灵，小精灵会沿着符阵的指向进行快速跃动。

在符阵的每一个位置，都有一个符号指向着另一个位置。小精灵就会在下一个时刻跳到对应的位置，然后再下一个时刻又会随着到达的位置上的指向来跳动。小精灵肯定不会撞到一起，这意味着任何两个位置都不会指向一个位置。

形式化地，如果一个位置 $i$ 的符号指向 $f(i)$，那么小精灵经过 $k$ 个时刻后到达的位置是 $f_k(i) = f(f_{k-1}(i))$，而 $f_0(i) = i$。

曾经在那里考察的人类学家 Z. Jack 记载道：“C 部落的族人相信能在精灵的奇怪舞蹈中预言未来将要发生的事。”并且留下了一张当时的照片，记载了这一壮观的场面。

然而，文明社会的战争打扰了 C 部落的和平，炮火摧毁了曾经的符阵。50 年后，C 部落的人拜托你来复原符阵，但照片上的符文也模糊不清了。

仅剩的线索只有几个，曾经的祭司告诉了你，这张照片是在仪式开始第 $k$ 个时刻拍摄的。照片上标记了每个精灵在最初来自哪里。

祭司的记忆是准确的，Z. Jack 的记载也没有差错，所以你肯定能够找到一种可能的最初的符阵。

{{ s('输入格式') }}

{{ self.input_file() }}

第一行两个整数 $n, k$，表示符阵中小精灵位置的数量以及仪式进行的时间。

接下来一行 $n$ 个整数 $1 \le p_i \le n$，表示在此时原本在 $i$ 位置的精灵到达了 $p_i$ 位置。保证对于 $i \neq j$，有 $p_i \neq p_j$。

{{ s('输出格式') }}

{{ self.output_file() }}

输出一行 $n$ 个数，表示原本的符阵。

注意到合法的答案可能有多种，你只需要输出其中一种。

{{ s('sample', 1) }}

{{ self.sample_text() }}

{{ self.title_sample_description() }}

对于这组数据，无论如何画符阵都会满足要求。

{{ s('sample', 2) }}

{{ self.sample_file() }}

该组样例的数据范围同第 4 个测试点。

{{ s('sample', 3) }}

{{ self.sample_file() }}

该组样例的数据范围同第 9 个测试点。

{{ s('sample', 4) }}

{{ self.sample_file() }}

该组样例的数据范围同第 16 个测试点。

{{ s('子任务') }}

对于 $100\%$ 的数据，保证 $n \le {{ tl.hn(prob.args['n']) }}$, $2 \le k \le {{ tl.hn(prob.args['k']) }}$

{{ tbl('data') }}

{{ s('如何测试你的输出') }}

使用 `spj.exe` 在命令行测试你的输出是否是一个合法的解，格式如下：

`spj.exe 输入文件名 输出文件名 参考答案文件名`

例如，测试第 3 组数据使用以下命令：

`spj.exe cycle3.in cycle3.out cycle3.ans`

如果您自己创建了一组输入，并没有参考答案文件，你可以创建一个空文件并且填写在参考答案对应的位置。但是 **spj 并不会帮你检查输入是否有一个合法的解**。
